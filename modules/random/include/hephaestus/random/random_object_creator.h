//=================================================================================================
// Copyright (C) 2023-2024 HEPHAESTUS Contributors
//=================================================================================================

#pragma once

#include <chrono>
#include <concepts>
#include <cstddef>
#include <random>
#include <type_traits>
#include <vector>

#include <fmt/format.h>
#include <magic_enum.hpp>

#include "hephaestus/utils/concepts.h"
#include "hephaestus/utils/exception.h"

namespace heph::random {

//=================================================================================================
// Random boolean creation
//=================================================================================================
template <BooleanType T>
[[nodiscard]] auto random(std::mt19937_64& mt) -> T {
  std::bernoulli_distribution dist;
  return dist(mt);
}

//=================================================================================================
// Random integer value creation
//=================================================================================================
template <typename T>
concept NonBooleanIntegralType = std::integral<T> && !BooleanType<T>;

template <NonBooleanIntegralType T>
[[nodiscard]] auto random(std::mt19937_64& mt) -> T {
  std::uniform_int_distribution<T> dist;
  return dist(mt);
}

//=================================================================================================
// Random floating point value creation
//=================================================================================================
template <std::floating_point T>
[[nodiscard]] auto random(std::mt19937_64& mt) -> T {
  std::uniform_real_distribution<T> dist;
  return dist(mt);
}

//=================================================================================================
// Random enum creation
//=================================================================================================
template <EnumType T>
[[nodiscard]] auto random(std::mt19937_64& mt) -> T {
  static const auto enum_values = magic_enum::enum_values<T>();
  std::uniform_int_distribution<size_t> dist(0, enum_values.size() - 1);
  return enum_values[dist(mt)];  // NOLINT(cppcoreguidelines-pro-bounds-constant-array-index)
}

//=================================================================================================
// Random timestamp creation
//=================================================================================================
namespace internal {
template <ChronoTimestampType T, size_t Year>
[[nodiscard]] constexpr auto createFinalTimestampOfTheYear() -> T {
  // The final date of the year is YYYY-12-31.
  constexpr auto YEAR = std::chrono::year{ Year };
  constexpr auto FINAL_MONTH = std::chrono::December;
  constexpr auto FINAL_DAY = std::chrono::year_month_day_last{ YEAR / FINAL_MONTH / std::chrono::last };
  constexpr auto FINAL_DATE_SYS_DAYS = std::chrono::sys_days{ FINAL_DAY };

  // The final time of the day is 23:59:59.999...
  constexpr auto FINAL_TIME = std::chrono::hours{ 24 } - typename T::duration{ 1 };
  // The final timestamp of the year is YYYY-12-31 23:59:59.999...
  constexpr auto TOTAL_TIME = FINAL_DATE_SYS_DAYS + FINAL_TIME;

  return T{ TOTAL_TIME.time_since_epoch() };
}
}  // namespace internal

/// Create a random timestamp between year 1970 and the year 2100.
template <ChronoTimestampType T>
[[nodiscard]] auto random(std::mt19937_64& mt) -> T {
  static constexpr auto MIN_DURATION = 0;  // Start of UNIX epoch time == year 1970.
  static constexpr auto MAX_YEAR = 2100;
  static constexpr auto FINAL_TIMESTAMP = internal::createFinalTimestampOfTheYear<T, MAX_YEAR>();
  static constexpr auto MAX_DURATION = FINAL_TIMESTAMP.time_since_epoch().count();  // End of year 2100.

  std::uniform_int_distribution<int64_t> duration_dist(MIN_DURATION, MAX_DURATION);
  const auto duration = typename T::duration{ duration_dist(mt) };
  const auto timestamp = T{ duration };

  return timestamp;
}

//=================================================================================================
// Random struct/class creation
//=================================================================================================
template <class T>
concept HasRandomMethod = requires(std::mt19937_64& mt) {
  { T::random(mt) } -> std::convertible_to<T>;
};

template <HasRandomMethod T>
[[nodiscard]] auto random(std::mt19937_64& mt) -> T {
  return T::random(mt);
}

//=================================================================================================
// Concept for random creatable types
//=================================================================================================
template <class T>
concept RandomCreatable = requires(std::mt19937_64& mt) {
  { random<T>(mt) } -> std::convertible_to<T>;
};

//=================================================================================================
// Internal helper functions for container types
//=================================================================================================
namespace internal {
[[nodiscard]] inline auto getSize(std::mt19937_64& mt, std::optional<size_t> fixed_size,
                                  bool allow_empty) -> size_t {
  if (fixed_size.has_value()) {
    throwExceptionIf<InvalidParameterException>(
        allow_empty == false && fixed_size.value() == 0,
        fmt::format("fixed_size must be non-zero if allow_empty == true"));
    return fixed_size.value();
  }

  static constexpr auto MAX_SIZE = 42ul;
  const auto min_size = allow_empty ? 0ul : 1ul;
  std::uniform_int_distribution<size_t> dist(min_size, MAX_SIZE);

  return dist(mt);
}
}  // namespace internal

//=================================================================================================
// Random string creation
//=================================================================================================
/// Generate a random string of characters, including special case characters and numbers.
template <StringType T>
[[nodiscard]] auto random(std::mt19937_64& mt, std::optional<size_t> fixed_size = std::nullopt,
                          bool allow_empty = true) -> T {
  const auto size = internal::getSize(mt, fixed_size, allow_empty);

  static constexpr auto PRINTABLE_ASCII_START = 32;  // Space
  static constexpr auto PRINTABLE_ASCII_END = 126;   // Equivalency sign - tilde
  std::uniform_int_distribution<unsigned char> char_dist(PRINTABLE_ASCII_START, PRINTABLE_ASCII_END);

  std::string random_string;
  random_string.reserve(size);

  auto gen_random_char = [&mt, &char_dist]() { return static_cast<char>(char_dist(mt)); };
  std::generate_n(std::back_inserter(random_string), size, gen_random_char);

  return random_string;
}

//=================================================================================================
// Random vector creation
//=================================================================================================
template <typename T>
concept RandomCreatableVector = VectorType<T> && RandomCreatable<typename T::value_type>;

/// Fill a vector with randomly generated values of type T.
template <RandomCreatableVector T>
[[nodiscard]] auto random(std::mt19937_64& mt, std::optional<size_t> fixed_size = std::nullopt,
                          bool allow_empty = true) -> T {
  const auto size = internal::getSize(mt, fixed_size, allow_empty);

  T vec;
  vec.reserve(size);

  auto gen = [&mt]() -> typename T::value_type { return random<typename T::value_type>(mt); };
  std::generate_n(std::back_inserter(vec), size, gen);

  return vec;
};

}  // namespace heph::random
